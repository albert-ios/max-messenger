const __rslib_import_meta_url__ = /*#__PURE__*/ function() {
    return 'undefined' == typeof document ? new (require('url'.replace('', ''))).URL('file:' + __filename).href : document.currentScript && document.currentScript.src || new URL('main.js', document.baseURI).href;
}();
var __webpack_modules__ = {
    "../../node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js" (module) {
        let p = process || {}, argv = p.argv || [], env = p.env || {};
        let isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || "win32" === p.platform || (p.stdout || {}).isTTY && "dumb" !== env.TERM || !!env.CI);
        let formatter = (open, close, replace = open)=>(input)=>{
                let string = "" + input, index = string.indexOf(close, open.length);
                return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
            };
        let replaceClose = (string, close, replace, index)=>{
            let result = "", cursor = 0;
            do {
                result += string.substring(cursor, index) + replace;
                cursor = index + close.length;
                index = string.indexOf(close, cursor);
            }while (~index);
            return result + string.substring(cursor);
        };
        let createColors = (enabled = isColorSupported)=>{
            let f = enabled ? formatter : ()=>String;
            return {
                isColorSupported: enabled,
                reset: f("\x1b[0m", "\x1b[0m"),
                bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
                dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
                italic: f("\x1b[3m", "\x1b[23m"),
                underline: f("\x1b[4m", "\x1b[24m"),
                inverse: f("\x1b[7m", "\x1b[27m"),
                hidden: f("\x1b[8m", "\x1b[28m"),
                strikethrough: f("\x1b[9m", "\x1b[29m"),
                black: f("\x1b[30m", "\x1b[39m"),
                red: f("\x1b[31m", "\x1b[39m"),
                green: f("\x1b[32m", "\x1b[39m"),
                yellow: f("\x1b[33m", "\x1b[39m"),
                blue: f("\x1b[34m", "\x1b[39m"),
                magenta: f("\x1b[35m", "\x1b[39m"),
                cyan: f("\x1b[36m", "\x1b[39m"),
                white: f("\x1b[37m", "\x1b[39m"),
                gray: f("\x1b[90m", "\x1b[39m"),
                bgBlack: f("\x1b[40m", "\x1b[49m"),
                bgRed: f("\x1b[41m", "\x1b[49m"),
                bgGreen: f("\x1b[42m", "\x1b[49m"),
                bgYellow: f("\x1b[43m", "\x1b[49m"),
                bgBlue: f("\x1b[44m", "\x1b[49m"),
                bgMagenta: f("\x1b[45m", "\x1b[49m"),
                bgCyan: f("\x1b[46m", "\x1b[49m"),
                bgWhite: f("\x1b[47m", "\x1b[49m"),
                blackBright: f("\x1b[90m", "\x1b[39m"),
                redBright: f("\x1b[91m", "\x1b[39m"),
                greenBright: f("\x1b[92m", "\x1b[39m"),
                yellowBright: f("\x1b[93m", "\x1b[39m"),
                blueBright: f("\x1b[94m", "\x1b[39m"),
                magentaBright: f("\x1b[95m", "\x1b[39m"),
                cyanBright: f("\x1b[96m", "\x1b[39m"),
                whiteBright: f("\x1b[97m", "\x1b[39m"),
                bgBlackBright: f("\x1b[100m", "\x1b[49m"),
                bgRedBright: f("\x1b[101m", "\x1b[49m"),
                bgGreenBright: f("\x1b[102m", "\x1b[49m"),
                bgYellowBright: f("\x1b[103m", "\x1b[49m"),
                bgBlueBright: f("\x1b[104m", "\x1b[49m"),
                bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
                bgCyanBright: f("\x1b[106m", "\x1b[49m"),
                bgWhiteBright: f("\x1b[107m", "\x1b[49m")
            };
        };
        module.exports = createColors();
        module.exports.createColors = createColors;
    },
    "../../node_modules/.pnpm/pirates@4.0.7/node_modules/pirates/lib/index.js" (module, exports1, __webpack_require__) {
        "use strict";
        module = __webpack_require__.nmd(module);
        const BuiltinModule = __webpack_require__("module");
        const path = __webpack_require__("path");
        const nodeModulesRegex = /^(?:.*[\\/])?node_modules(?:[\\/].*)?$/;
        const Module = module.constructor.length > 1 ? module.constructor : BuiltinModule;
        const HOOK_RETURNED_NOTHING_ERROR_MESSAGE = "[Pirates] A hook returned a non-string, or nothing at all! This is a violation of intergalactic law!\n--------------------\nIf you have no idea what this means or what Pirates is, let me explain: Pirates is a module that makes it easy to implement require hooks. One of the require hooks you're using uses it. One of these require hooks didn't return anything from it's handler, so we don't know what to do. You might want to debug this.";
        function shouldCompile(filename, exts, matcher, ignoreNodeModules) {
            if ('string' != typeof filename) return false;
            if (-1 === exts.indexOf(path.extname(filename))) return false;
            const resolvedFilename = path.resolve(filename);
            if (ignoreNodeModules && nodeModulesRegex.test(resolvedFilename)) return false;
            if (matcher && 'function' == typeof matcher) return !!matcher(resolvedFilename);
            return true;
        }
        function addHook(hook, opts = {}) {
            let reverted = false;
            const loaders = [];
            const oldLoaders = [];
            let exts;
            const originalJSLoader = Module._extensions['.js'];
            const matcher = opts.matcher || null;
            const ignoreNodeModules = false !== opts.ignoreNodeModules;
            exts = opts.extensions || opts.exts || opts.extension || opts.ext || [
                '.js'
            ];
            if (!Array.isArray(exts)) exts = [
                exts
            ];
            exts.forEach((ext)=>{
                if ('string' != typeof ext) throw new TypeError(`Invalid Extension: ${ext}`);
                const oldLoader = Module._extensions[ext] || originalJSLoader;
                oldLoaders[ext] = Module._extensions[ext];
                loaders[ext] = Module._extensions[ext] = function(mod, filename) {
                    let compile;
                    if (!reverted) {
                        if (shouldCompile(filename, exts, matcher, ignoreNodeModules)) {
                            compile = mod._compile;
                            mod._compile = function(code) {
                                mod._compile = compile;
                                const newCode = hook(code, filename);
                                if ('string' != typeof newCode) throw new Error(HOOK_RETURNED_NOTHING_ERROR_MESSAGE);
                                return mod._compile(newCode, filename);
                            };
                        }
                    }
                    oldLoader(mod, filename);
                };
            });
            return function() {
                if (reverted) return;
                reverted = true;
                exts.forEach((ext)=>{
                    if (Module._extensions[ext] === loaders[ext]) if (oldLoaders[ext]) Module._extensions[ext] = oldLoaders[ext];
                    else delete Module._extensions[ext];
                });
            };
        }
        exports1.addHook = addHook;
    },
    "./src/utils/rspackCore.ts" (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            Z: ()=>rspack
        });
        const external_node_module_namespaceObject = require("node:module");
        const rspackCore_require = (0, external_node_module_namespaceObject.createRequire)(__rslib_import_meta_url__);
        const rspack = rspackCore_require("@rspack/core");
    },
    module (module) {
        "use strict";
        module.exports = require("module");
    },
    "node:fs" (module) {
        "use strict";
        module.exports = require("node:fs");
    },
    "node:path" (module) {
        "use strict";
        module.exports = require("node:path");
    },
    path (module) {
        "use strict";
        module.exports = require("path");
    }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        id: moduleId,
        loaded: false,
        exports: {}
    };
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    module.loaded = true;
    return module.exports;
}
__webpack_require__.m = __webpack_modules__;
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.f = {};
    __webpack_require__.e = (chunkId)=>Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key)=>{
            __webpack_require__.f[key](chunkId, promises);
            return promises;
        }, []));
})();
(()=>{
    __webpack_require__.u = (chunkId)=>"0~" + chunkId + ".js";
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
(()=>{
    __webpack_require__.nmd = (module)=>{
        module.paths = [];
        if (!module.children) module.children = [];
        return module;
    };
})();
(()=>{
    var installedChunks = {
        410: 1
    };
    var installChunk = (chunk)=>{
        var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
        for(var moduleId in moreModules)if (__webpack_require__.o(moreModules, moduleId)) __webpack_require__.m[moduleId] = moreModules[moduleId];
        if (runtime) runtime(__webpack_require__);
        for(var i = 0; i < chunkIds.length; i++)installedChunks[chunkIds[i]] = 1;
    };
    __webpack_require__.f.require = (chunkId, promises)=>{
        if (!installedChunks[chunkId]) installChunk(require("./" + __webpack_require__.u(chunkId)));
    };
})();
var __webpack_exports__ = {};
(()=>{
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
        definePlugin: ()=>definePlugin,
        RspackCLI: ()=>RspackCLI,
        defineConfig: ()=>defineConfig
    });
    var external_node_path_ = __webpack_require__("node:path");
    var external_node_path_default = /*#__PURE__*/ __webpack_require__.n(external_node_path_);
    const external_node_util_namespaceObject = require("node:util");
    var external_node_util_default = /*#__PURE__*/ __webpack_require__.n(external_node_util_namespaceObject);
    const external_events_namespaceObject = require("events");
    function toArr(any) {
        return null == any ? [] : Array.isArray(any) ? any : [
            any
        ];
    }
    function toVal(out, key, val, opts) {
        var x, old = out[key], nxt = ~opts.string.indexOf(key) ? null == val || true === val ? '' : String(val) : 'boolean' == typeof val ? val : ~opts.boolean.indexOf(key) ? 'false' === val ? false : 'true' === val || (out._.push((x = +val, 0 * x === 0) ? x : val), !!val) : (x = +val, 0 * x === 0) ? x : val;
        out[key] = null == old ? nxt : Array.isArray(old) ? old.concat(nxt) : [
            old,
            nxt
        ];
    }
    function mri2(args, opts) {
        args = args || [];
        opts = opts || {};
        var k, arr, arg, name, val, out = {
            _: []
        };
        var i = 0, j = 0, idx = 0, len = args.length;
        const alibi = void 0 !== opts.alias;
        const strict = void 0 !== opts.unknown;
        const defaults = void 0 !== opts.default;
        opts.alias = opts.alias || {};
        opts.string = toArr(opts.string);
        opts.boolean = toArr(opts.boolean);
        if (alibi) for(k in opts.alias){
            arr = opts.alias[k] = toArr(opts.alias[k]);
            for(i = 0; i < arr.length; i++)(opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);
        }
        for(i = opts.boolean.length; i-- > 0;){
            arr = opts.alias[opts.boolean[i]] || [];
            for(j = arr.length; j-- > 0;)opts.boolean.push(arr[j]);
        }
        for(i = opts.string.length; i-- > 0;){
            arr = opts.alias[opts.string[i]] || [];
            for(j = arr.length; j-- > 0;)opts.string.push(arr[j]);
        }
        if (defaults) for(k in opts.default){
            name = typeof opts.default[k];
            arr = opts.alias[k] = opts.alias[k] || [];
            if (void 0 !== opts[name]) {
                opts[name].push(k);
                for(i = 0; i < arr.length; i++)opts[name].push(arr[i]);
            }
        }
        const keys = strict ? Object.keys(opts.alias) : [];
        for(i = 0; i < len; i++){
            arg = args[i];
            if ('--' === arg) {
                out._ = out._.concat(args.slice(++i));
                break;
            }
            for(j = 0; j < arg.length && 45 === arg.charCodeAt(j); j++);
            if (0 === j) out._.push(arg);
            else if ('no-' === arg.substring(j, j + 3)) {
                name = arg.substring(j + 3);
                if (strict && !~keys.indexOf(name)) return opts.unknown(arg);
                out[name] = false;
            } else {
                for(idx = j + 1; idx < arg.length && 61 !== arg.charCodeAt(idx); idx++);
                name = arg.substring(j, idx);
                val = arg.substring(++idx) || i + 1 === len || 45 === ('' + args[i + 1]).charCodeAt(0) || args[++i];
                arr = 2 === j ? [
                    name
                ] : name;
                for(idx = 0; idx < arr.length; idx++){
                    name = arr[idx];
                    if (strict && !~keys.indexOf(name)) return opts.unknown('-'.repeat(j) + name);
                    toVal(out, name, idx + 1 < arr.length || val, opts);
                }
            }
        }
        if (defaults) {
            for(k in opts.default)if (void 0 === out[k]) out[k] = opts.default[k];
        }
        if (alibi) for(k in out){
            arr = opts.alias[k] || [];
            while(arr.length > 0)out[arr.shift()] = out[k];
        }
        return out;
    }
    const removeBrackets = (v)=>v.replace(/[<[].+/, "").trim();
    const findAllBrackets = (v)=>{
        const ANGLED_BRACKET_RE_GLOBAL = /<([^>]+)>/g;
        const SQUARE_BRACKET_RE_GLOBAL = /\[([^\]]+)\]/g;
        const res = [];
        const parse = (match)=>{
            let variadic = false;
            let value = match[1];
            if (value.startsWith("...")) {
                value = value.slice(3);
                variadic = true;
            }
            return {
                required: match[0].startsWith("<"),
                value,
                variadic
            };
        };
        let angledMatch;
        while(angledMatch = ANGLED_BRACKET_RE_GLOBAL.exec(v))res.push(parse(angledMatch));
        let squareMatch;
        while(squareMatch = SQUARE_BRACKET_RE_GLOBAL.exec(v))res.push(parse(squareMatch));
        return res;
    };
    const getMriOptions = (options)=>{
        const result = {
            alias: {},
            boolean: []
        };
        for (const [index, option] of options.entries()){
            if (option.names.length > 1) result.alias[option.names[0]] = option.names.slice(1);
            if (option.isBoolean) if (option.negated) {
                const hasStringTypeOption = options.some((o, i)=>i !== index && o.names.some((name)=>option.names.includes(name)) && "boolean" == typeof o.required);
                if (!hasStringTypeOption) result.boolean.push(option.names[0]);
            } else result.boolean.push(option.names[0]);
        }
        return result;
    };
    const findLongest = (arr)=>arr.sort((a, b)=>a.length > b.length ? -1 : 1)[0];
    const padRight = (str, length)=>str.length >= length ? str : `${str}${" ".repeat(length - str.length)}`;
    const camelcase = (input)=>input.replace(/([a-z])-([a-z])/g, (_, p1, p2)=>p1 + p2.toUpperCase());
    const setDotProp = (obj, keys, val)=>{
        let i = 0;
        let length = keys.length;
        let t = obj;
        let x;
        for(; i < length; ++i){
            x = t[keys[i]];
            t = t[keys[i]] = i === length - 1 ? val : null != x ? x : !~keys[i + 1].indexOf(".") && +keys[i + 1] > -1 ? [] : {};
        }
    };
    const setByType = (obj, transforms)=>{
        for (const key of Object.keys(transforms)){
            const transform = transforms[key];
            if (transform.shouldTransform) {
                obj[key] = Array.prototype.concat.call([], obj[key]);
                if ("function" == typeof transform.transformFunction) obj[key] = obj[key].map(transform.transformFunction);
            }
        }
    };
    const getFileName = (input)=>{
        const m = /([^\\\/]+)$/.exec(input);
        return m ? m[1] : "";
    };
    const camelcaseOptionName = (name)=>name.split(".").map((v, i)=>0 === i ? camelcase(v) : v).join(".");
    class CACError extends Error {
        constructor(message){
            super(message);
            this.name = this.constructor.name;
            if ("function" == typeof Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
            else this.stack = new Error(message).stack;
        }
    }
    class Option {
        constructor(rawName, description, config){
            this.rawName = rawName;
            this.description = description;
            this.config = Object.assign({}, config);
            rawName = rawName.replace(/\.\*/g, "");
            this.negated = false;
            this.names = removeBrackets(rawName).split(",").map((v)=>{
                let name = v.trim().replace(/^-{1,2}/, "");
                if (name.startsWith("no-")) {
                    this.negated = true;
                    name = name.replace(/^no-/, "");
                }
                return camelcaseOptionName(name);
            }).sort((a, b)=>a.length > b.length ? 1 : -1);
            this.name = this.names[this.names.length - 1];
            if (this.negated && null == this.config.default) this.config.default = true;
            if (rawName.includes("<")) this.required = true;
            else if (rawName.includes("[")) this.required = false;
            else this.isBoolean = true;
        }
    }
    const processArgs = process.argv;
    const platformInfo = `${process.platform}-${process.arch} node-${process.version}`;
    class Command {
        constructor(rawName, description, config = {}, cli){
            this.rawName = rawName;
            this.description = description;
            this.config = config;
            this.cli = cli;
            this.options = [];
            this.aliasNames = [];
            this.name = removeBrackets(rawName);
            this.args = findAllBrackets(rawName);
            this.examples = [];
        }
        usage(text) {
            this.usageText = text;
            return this;
        }
        allowUnknownOptions() {
            this.config.allowUnknownOptions = true;
            return this;
        }
        ignoreOptionDefaultValue() {
            this.config.ignoreOptionDefaultValue = true;
            return this;
        }
        version(version, customFlags = "-v, --version") {
            this.versionNumber = version;
            this.option(customFlags, "Display version number");
            return this;
        }
        example(example) {
            this.examples.push(example);
            return this;
        }
        option(rawName, description, config) {
            const option = new Option(rawName, description, config);
            this.options.push(option);
            return this;
        }
        alias(name) {
            this.aliasNames.push(name);
            return this;
        }
        action(callback) {
            this.commandAction = callback;
            return this;
        }
        isMatched(name) {
            return this.name === name || this.aliasNames.includes(name);
        }
        get isDefaultCommand() {
            return "" === this.name || this.aliasNames.includes("!");
        }
        get isGlobalCommand() {
            return this instanceof GlobalCommand;
        }
        hasOption(name) {
            name = name.split(".")[0];
            return this.options.find((option)=>option.names.includes(name));
        }
        outputHelp() {
            const { name, commands } = this.cli;
            const { versionNumber, options: globalOptions, helpCallback } = this.cli.globalCommand;
            let sections = [
                {
                    body: `${name}${versionNumber ? `/${versionNumber}` : ""}`
                }
            ];
            sections.push({
                title: "Usage",
                body: `  $ ${name} ${this.usageText || this.rawName}`
            });
            const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;
            if (showCommands) {
                const longestCommandName = findLongest(commands.map((command)=>command.rawName));
                sections.push({
                    title: "Commands",
                    body: commands.map((command)=>`  ${padRight(command.rawName, longestCommandName.length)}  ${command.description}`).join("\n")
                });
                sections.push({
                    title: "For more info, run any command with the `--help` flag",
                    body: commands.map((command)=>`  $ ${name}${"" === command.name ? "" : ` ${command.name}`} --help`).join("\n")
                });
            }
            let options = this.isGlobalCommand ? globalOptions : [
                ...this.options,
                ...globalOptions || []
            ];
            if (!this.isGlobalCommand && !this.isDefaultCommand) options = options.filter((option)=>"version" !== option.name);
            if (options.length > 0) {
                const longestOptionName = findLongest(options.map((option)=>option.rawName));
                sections.push({
                    title: "Options",
                    body: options.map((option)=>`  ${padRight(option.rawName, longestOptionName.length)}  ${option.description} ${void 0 === option.config.default ? "" : `(default: ${option.config.default})`}`).join("\n")
                });
            }
            if (this.examples.length > 0) sections.push({
                title: "Examples",
                body: this.examples.map((example)=>{
                    if ("function" == typeof example) return example(name);
                    return example;
                }).join("\n")
            });
            if (helpCallback) sections = helpCallback(sections) || sections;
            console.log(sections.map((section)=>section.title ? `${section.title}:
${section.body}` : section.body).join("\n\n"));
        }
        outputVersion() {
            const { name } = this.cli;
            const { versionNumber } = this.cli.globalCommand;
            if (versionNumber) console.log(`${name}/${versionNumber} ${platformInfo}`);
        }
        checkRequiredArgs() {
            const minimalArgsCount = this.args.filter((arg)=>arg.required).length;
            if (this.cli.args.length < minimalArgsCount) throw new CACError(`missing required args for command \`${this.rawName}\``);
        }
        checkUnknownOptions() {
            const { options, globalCommand } = this.cli;
            if (!this.config.allowUnknownOptions) {
                for (const name of Object.keys(options))if ("--" !== name && !this.hasOption(name) && !globalCommand.hasOption(name)) throw new CACError(`Unknown option \`${name.length > 1 ? `--${name}` : `-${name}`}\``);
            }
        }
        checkOptionValue() {
            const { options: parsedOptions, globalCommand } = this.cli;
            const options = [
                ...globalCommand.options,
                ...this.options
            ];
            for (const option of options){
                const value = parsedOptions[option.name.split(".")[0]];
                if (option.required) {
                    const hasNegated = options.some((o)=>o.negated && o.names.includes(option.name));
                    if (true === value || false === value && !hasNegated) throw new CACError(`option \`${option.rawName}\` value is missing`);
                }
            }
        }
    }
    class GlobalCommand extends Command {
        constructor(cli){
            super("@@global@@", "", {}, cli);
        }
    }
    var __assign = Object.assign;
    class CAC extends external_events_namespaceObject.EventEmitter {
        constructor(name = ""){
            super();
            this.name = name;
            this.commands = [];
            this.rawArgs = [];
            this.args = [];
            this.options = {};
            this.globalCommand = new GlobalCommand(this);
            this.globalCommand.usage("<command> [options]");
        }
        usage(text) {
            this.globalCommand.usage(text);
            return this;
        }
        command(rawName, description, config) {
            const command = new Command(rawName, description || "", config, this);
            command.globalCommand = this.globalCommand;
            this.commands.push(command);
            return command;
        }
        option(rawName, description, config) {
            this.globalCommand.option(rawName, description, config);
            return this;
        }
        help(callback) {
            this.globalCommand.option("-h, --help", "Display this message");
            this.globalCommand.helpCallback = callback;
            this.showHelpOnExit = true;
            return this;
        }
        version(version, customFlags = "-v, --version") {
            this.globalCommand.version(version, customFlags);
            this.showVersionOnExit = true;
            return this;
        }
        example(example) {
            this.globalCommand.example(example);
            return this;
        }
        outputHelp() {
            if (this.matchedCommand) this.matchedCommand.outputHelp();
            else this.globalCommand.outputHelp();
        }
        outputVersion() {
            this.globalCommand.outputVersion();
        }
        setParsedInfo({ args, options }, matchedCommand, matchedCommandName) {
            this.args = args;
            this.options = options;
            if (matchedCommand) this.matchedCommand = matchedCommand;
            if (matchedCommandName) this.matchedCommandName = matchedCommandName;
            return this;
        }
        unsetMatchedCommand() {
            this.matchedCommand = void 0;
            this.matchedCommandName = void 0;
        }
        parse(argv = processArgs, { run = true } = {}) {
            this.rawArgs = argv;
            if (!this.name) this.name = argv[1] ? getFileName(argv[1]) : "cli";
            let shouldParse = true;
            for (const command of this.commands){
                const parsed = this.mri(argv.slice(2), command);
                const commandName = parsed.args[0];
                if (command.isMatched(commandName)) {
                    shouldParse = false;
                    const parsedInfo = __assign(__assign({}, parsed), {
                        args: parsed.args.slice(1)
                    });
                    this.setParsedInfo(parsedInfo, command, commandName);
                    this.emit(`command:${commandName}`, command);
                }
            }
            if (shouldParse) {
                for (const command of this.commands)if ("" === command.name) {
                    shouldParse = false;
                    const parsed = this.mri(argv.slice(2), command);
                    this.setParsedInfo(parsed, command);
                    this.emit("command:!", command);
                }
            }
            if (shouldParse) {
                const parsed = this.mri(argv.slice(2));
                this.setParsedInfo(parsed);
            }
            if (this.options.help && this.showHelpOnExit) {
                this.outputHelp();
                run = false;
                this.unsetMatchedCommand();
            }
            if (this.options.version && this.showVersionOnExit && null == this.matchedCommandName) {
                this.outputVersion();
                run = false;
                this.unsetMatchedCommand();
            }
            const parsedArgv = {
                args: this.args,
                options: this.options
            };
            if (run) this.runMatchedCommand();
            if (!this.matchedCommand && this.args[0]) this.emit("command:*");
            return parsedArgv;
        }
        mri(argv, command) {
            const cliOptions = [
                ...this.globalCommand.options,
                ...command ? command.options : []
            ];
            const mriOptions = getMriOptions(cliOptions);
            let argsAfterDoubleDashes = [];
            const doubleDashesIndex = argv.indexOf("--");
            if (doubleDashesIndex > -1) {
                argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);
                argv = argv.slice(0, doubleDashesIndex);
            }
            let parsed = mri2(argv, mriOptions);
            parsed = Object.keys(parsed).reduce((res, name)=>__assign(__assign({}, res), {
                    [camelcaseOptionName(name)]: parsed[name]
                }), {
                _: []
            });
            const args = parsed._;
            const options = {
                "--": argsAfterDoubleDashes
            };
            const ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue;
            let transforms = Object.create(null);
            for (const cliOption of cliOptions){
                if (!ignoreDefault && void 0 !== cliOption.config.default) for (const name of cliOption.names)options[name] = cliOption.config.default;
                if (Array.isArray(cliOption.config.type)) {
                    if (void 0 === transforms[cliOption.name]) {
                        transforms[cliOption.name] = Object.create(null);
                        transforms[cliOption.name]["shouldTransform"] = true;
                        transforms[cliOption.name]["transformFunction"] = cliOption.config.type[0];
                    }
                }
            }
            for (const key of Object.keys(parsed))if ("_" !== key) {
                const keys = key.split(".");
                setDotProp(options, keys, parsed[key]);
                setByType(options, transforms);
            }
            return {
                args,
                options
            };
        }
        runMatchedCommand() {
            const { args, options, matchedCommand: command } = this;
            if (!command || !command.commandAction) return;
            command.checkUnknownOptions();
            command.checkOptionValue();
            command.checkRequiredArgs();
            const actionArgs = [];
            command.args.forEach((arg, index)=>{
                if (arg.variadic) actionArgs.push(args.slice(index));
                else actionArgs.push(args[index]);
            });
            actionArgs.push(options);
            return command.commandAction.apply(this, actionArgs);
        }
    }
    const cac = (name = "")=>new CAC(name);
    const dist = cac;
    var picocolors = __webpack_require__("../../node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js");
    var external_node_fs_ = __webpack_require__("node:fs");
    var external_node_fs_default = /*#__PURE__*/ __webpack_require__.n(external_node_fs_);
    const commonOptions = (command)=>command.option("-c, --config <path>", "config file").option("--config-name <name>", "Name(s) of the configuration to use.", {
            type: [
                String
            ],
            default: []
        }).option("--config-loader <loader>", "Specify the loader to load the config file, can be `native` or `register`.", {
            default: "register"
        }).option("--env <env>", "env passed to config function", {
            type: [
                String
            ],
            default: []
        }).option("--node-env <value>", "sets `process.env.NODE_ENV` to be specified value");
    function normalizeDevtoolOption(value) {
        if ("string" == typeof value) {
            const trimmed = value.trim();
            if ("" === trimmed || "false" === trimmed) return false;
            if ("true" === trimmed) return "source-map";
            return trimmed;
        }
        if ("boolean" == typeof value) return value ? "source-map" : false;
    }
    const normalizeCommonOptions = (options, action)=>{
        const isEmptyArray = (arr)=>Array.isArray(arr) && 0 === arr.length;
        for (const key of [
            "entry",
            "configName"
        ]){
            const val = options[key];
            if (isEmptyArray(val)) options[key] = void 0;
        }
        const env = Array.isArray(options.env) ? normalizeEnvToObject(options) : {};
        options.env = env;
        if ("serve" === action) setBuiltinEnvArg(env, "SERVE", true);
        else if ("build" === action) if (options.watch) setBuiltinEnvArg(env, "WATCH", true);
        else {
            setBuiltinEnvArg(env, "BUNDLE", true);
            setBuiltinEnvArg(env, "BUILD", true);
        }
        if ("devtool" in options) options.devtool = normalizeDevtoolOption(options.devtool);
    };
    const commonOptionsForBuildAndServe = (command)=>command.option("--analyze", "analyze").option("-d, --devtool <value>", "specify a developer tool for debugging. Defaults to `cheap-module-source-map` in development and `source-map` in production.").option("--entry <entry>", "entry file", {
            type: [
                String
            ],
            default: []
        }).option("-m, --mode <mode>", "mode").option("-o, --output-path <dir>", "output path dir").option("--profile", "capture timing information for each module").option("-w, --watch", "watch");
    function setBuiltinEnvArg(env, envNameSuffix, value) {
        const envName = `RSPACK_${envNameSuffix}`;
        if (!(envName in env)) env[envName] = value;
    }
    function normalizeEnvToObject(options) {
        function parseValue(previous, value) {
            const [allKeys, val] = value.split(/=(.+)/, 2);
            const splitKeys = allKeys.split(/\.(?!$)/);
            let prevRef = previous;
            splitKeys.forEach((key, index)=>{
                let someKey = key;
                if (someKey.endsWith("=")) {
                    someKey = someKey.slice(0, -1);
                    prevRef[someKey] = void 0;
                    return;
                }
                if (!prevRef[someKey] || "string" == typeof prevRef[someKey]) prevRef[someKey] = {};
                if (index === splitKeys.length - 1) if ("string" == typeof val) prevRef[someKey] = val;
                else prevRef[someKey] = true;
                prevRef = prevRef[someKey];
            });
            return previous;
        }
        return (options.env ?? []).reduce(parseValue, {});
    }
    function setDefaultNodeEnv(options, defaultEnv) {
        if (void 0 === process.env.NODE_ENV) process.env.NODE_ENV = "string" == typeof options.nodeEnv ? options.nodeEnv : defaultEnv;
    }
    async function runBuild(cli, options) {
        setDefaultNodeEnv(options, "production");
        normalizeCommonOptions(options, "build");
        const logger = cli.getLogger();
        let createJsonStringifyStream;
        if (options.json) {
            const jsonExt = await import("@discoveryjs/json-ext");
            createJsonStringifyStream = jsonExt.default.stringifyStream;
        }
        const errorHandler = (error, stats)=>{
            if (error) {
                logger.error(error);
                process.exit(2);
            }
            if (stats?.hasErrors()) process.exitCode = 1;
            if (!compiler || !stats) return;
            const getStatsOptions = ()=>{
                if (cli.isMultipleCompiler(compiler)) return {
                    children: compiler.compilers.map((item)=>item.options ? item.options.stats : void 0)
                };
                return compiler.options?.stats;
            };
            const statsOptions = getStatsOptions();
            if (options.json && createJsonStringifyStream) {
                const handleWriteError = (error)=>{
                    logger.error(error);
                    process.exit(2);
                };
                if (true === options.json) createJsonStringifyStream(stats.toJson(statsOptions)).on("error", handleWriteError).pipe(process.stdout).on("error", handleWriteError).on("close", ()=>process.stdout.write("\n"));
                else if ("string" == typeof options.json) createJsonStringifyStream(stats.toJson(statsOptions)).on("error", handleWriteError).pipe(external_node_fs_default().createWriteStream(options.json)).on("error", handleWriteError).on("close", ()=>{
                    process.stderr.write(`[rspack-cli] ${cli.colors.green(`stats are successfully stored as json to ${options.json}`)}\n`);
                });
            } else {
                const printedStats = stats.toString(statsOptions);
                if (printedStats) logger.raw(printedStats);
            }
        };
        const compiler = await cli.createCompiler(options, "build", errorHandler);
        if (!compiler || cli.isWatch(compiler)) return;
        compiler.run((error, stats)=>{
            compiler.close((closeErr)=>{
                if (closeErr) logger.error(closeErr);
                errorHandler(error, stats);
            });
        });
    }
    class BuildCommand {
        async apply(cli) {
            const command = cli.program.command("", "run the Rspack build").alias("build").alias("bundle").alias("b");
            commonOptionsForBuildAndServe(commonOptions(command)).option("--json [path]", "emit stats json");
            command.action(async (options)=>{
                await runBuild(cli, options);
            });
        }
    }
    var rspackCore = __webpack_require__("./src/utils/rspackCore.ts");
    class PreviewCommand {
        async apply(cli) {
            const command = cli.program.command("preview [dir]", "run the Rspack server for build output").alias("p");
            commonOptions(command).option("--public-path <path>", "static resource server path").option("--port <port>", "preview server port").option("--host <host>", "preview server host").option("--open", "open browser").option("--server <config>", "Configuration items for the server.");
            command.action(async (dir, options)=>{
                setDefaultNodeEnv(options, "production");
                normalizeCommonOptions(options, "preview");
                const { RspackDevServer } = await import("@rspack/dev-server");
                let { config } = await cli.loadConfig(options);
                config = await getPreviewConfig(config, options, dir);
                if (!Array.isArray(config)) config = [
                    config
                ];
                const singleConfig = config.find((item)=>item.devServer) || config[0];
                const devServerOptions = singleConfig.devServer;
                try {
                    const compiler = (0, rspackCore.Z)({
                        entry: {}
                    });
                    if (!compiler) return;
                    const server = new RspackDevServer(devServerOptions, compiler);
                    await server.start();
                } catch (error) {
                    const logger = cli.getLogger();
                    logger.error(error);
                    process.exit(2);
                }
            });
        }
    }
    async function getPreviewConfig(item, options, dir) {
        const DEFAULT_ROOT = "dist";
        const internalPreviewConfig = async (item)=>{
            item.devServer = {
                static: {
                    directory: dir ? external_node_path_default().join(item.context ?? process.cwd(), dir) : item.output?.path ?? external_node_path_default().join(item.context ?? process.cwd(), DEFAULT_ROOT),
                    publicPath: options.publicPath ?? "/"
                },
                port: options.port ?? 8080,
                proxy: item.devServer?.proxy,
                host: options.host ?? item.devServer?.host,
                open: options.open ?? item.devServer?.open,
                server: options.server ?? item.devServer?.server,
                historyApiFallback: item.devServer?.historyApiFallback
            };
            return item;
        };
        if (Array.isArray(item)) return Promise.all(item.map(internalPreviewConfig));
        return internalPreviewConfig(item);
    }
    function normalizeHotOption(value) {
        if ("false" === value) return false;
        if ("true" === value) return true;
        return value;
    }
    class ServeCommand {
        async apply(cli) {
            const command = cli.program.command("serve", "run the rspack dev server.").alias("server").alias("s").alias("dev");
            commonOptionsForBuildAndServe(commonOptions(command)).option("--hot [mode]", "enables hot module replacement").option("--port <port>", "allows to specify a port to use").option("--host <host>", "allows to specify a hostname to use");
            command.action(async (cliOptions)=>{
                setDefaultNodeEnv(cliOptions, "development");
                normalizeCommonOptions(cliOptions, "serve");
                cliOptions.hot = normalizeHotOption(cliOptions.hot);
                const { RspackDevServer } = await import("@rspack/dev-server");
                const compiler = await cli.createCompiler(cliOptions, "serve");
                if (!compiler) return;
                const compilers = cli.isMultipleCompiler(compiler) ? compiler.compilers : [
                    compiler
                ];
                const possibleCompilers = compilers.filter((compiler)=>compiler.options.devServer);
                const usedPorts = [];
                const servers = [];
                const compilerForDevServer = possibleCompilers.length > 0 ? possibleCompilers[0] : compilers[0];
                for (const compiler of compilers){
                    const devServer = compiler.options.devServer ??= {};
                    devServer.hot = cliOptions.hot ?? devServer.hot ?? true;
                    if (false !== devServer.client) {
                        if (true === devServer.client || null == devServer.client) devServer.client = {};
                        devServer.client = {
                            overlay: {
                                errors: true,
                                warnings: false
                            },
                            ...devServer.client
                        };
                    }
                }
                const devServerOptions = compilerForDevServer.options.devServer ??= {};
                const { setupMiddlewares } = devServerOptions;
                const lazyCompileMiddleware = rspackCore.Z.experiments.lazyCompilationMiddleware(compiler);
                devServerOptions.setupMiddlewares = (middlewares, server)=>{
                    let finalMiddlewares = middlewares;
                    if (setupMiddlewares) finalMiddlewares = setupMiddlewares(finalMiddlewares, server);
                    return [
                        ...finalMiddlewares,
                        lazyCompileMiddleware
                    ];
                };
                devServerOptions.hot = cliOptions.hot ?? devServerOptions.hot ?? true;
                devServerOptions.host = cliOptions.host || devServerOptions.host;
                devServerOptions.port = cliOptions.port ?? devServerOptions.port;
                if (false !== devServerOptions.client) {
                    if (true === devServerOptions.client || null == devServerOptions.client) devServerOptions.client = {};
                    devServerOptions.client = {
                        overlay: {
                            errors: true,
                            warnings: false
                        },
                        ...devServerOptions.client
                    };
                }
                if (devServerOptions.port) {
                    const portNumber = Number(devServerOptions.port);
                    if (!Number.isNaN(portNumber)) {
                        if (usedPorts.find((port)=>portNumber === port)) throw new Error("Unique ports must be specified for each devServer option in your rspack configuration. Alternatively, run only 1 devServer config using the --config-name flag to specify your desired config.");
                        usedPorts.push(portNumber);
                    }
                }
                try {
                    const server = new RspackDevServer(devServerOptions, compiler);
                    await server.start();
                    servers.push(server);
                } catch (error) {
                    const logger = cli.getLogger();
                    logger.error(error);
                    process.exit(2);
                }
            });
        }
    }
    var lib = __webpack_require__("../../node_modules/.pnpm/pirates@4.0.7/node_modules/pirates/lib/index.js");
    const external_node_url_namespaceObject = require("node:url");
    const readPackageUp = (cwd = process.cwd())=>{
        let currentDir = external_node_path_default().resolve(cwd);
        let packageJsonPath = external_node_path_default().join(currentDir, "package.json");
        while(!external_node_fs_default().existsSync(packageJsonPath)){
            const parentDir = external_node_path_default().dirname(currentDir);
            if (parentDir === currentDir) return null;
            currentDir = parentDir;
            packageJsonPath = external_node_path_default().join(currentDir, "package.json");
        }
        try {
            return JSON.parse(external_node_fs_default().readFileSync(packageJsonPath, "utf8"));
        } catch  {
            return null;
        }
    };
    const utils_readPackageUp = readPackageUp;
    const isEsmFile = (filePath)=>{
        if (/\.(mjs|mts)$/.test(filePath)) return true;
        if (/\.(cjs|cts)$/.test(filePath)) return false;
        const packageJson = utils_readPackageUp(external_node_path_default().dirname(filePath));
        return packageJson?.type === "module";
    };
    const crossImport = async (path)=>{
        if (isEsmFile(path)) {
            const url = (0, external_node_url_namespaceObject.pathToFileURL)(path).href;
            const { default: config } = await import(url);
            return config;
        }
        let result = require(path);
        if (result && "object" == typeof result && "default" in result) result = result.default || {};
        return result;
    };
    const DEFAULT_EXTENSIONS = [
        ".js",
        ".ts",
        ".mjs",
        ".mts",
        ".cjs",
        ".cts"
    ];
    const findConfig = (basePath)=>DEFAULT_EXTENSIONS.map((ext)=>basePath + ext).find(external_node_fs_default().existsSync);
    const utils_findConfig = findConfig;
    const TS_EXTENSION = [
        ".ts",
        ".cts",
        ".mts"
    ];
    const isTsFile = (configPath)=>{
        const ext = external_node_path_default().extname(configPath);
        return TS_EXTENSION.includes(ext);
    };
    const utils_isTsFile = isTsFile;
    const injectInlineSourceMap = ({ code, map })=>{
        if (map) {
            const base64Map = Buffer.from(map, "utf8").toString("base64");
            const sourceMapContent = `//# sourceMappingURL=data:application/json;charset=utf-8;base64,${base64Map}`;
            return `${code}\n${sourceMapContent}`;
        }
        return code;
    };
    function compile(sourcecode, filename) {
        const { code, map } = rspackCore.Z.experiments.swc.transformSync(sourcecode, {
            jsc: {
                parser: {
                    syntax: "typescript",
                    tsx: false,
                    decorators: true,
                    dynamicImport: true
                }
            },
            filename: filename,
            module: {
                type: "commonjs"
            },
            sourceMaps: true,
            isModule: true
        });
        return injectInlineSourceMap({
            code,
            map
        });
    }
    const loadConfig_DEFAULT_CONFIG_NAME = "rspack.config";
    const registerLoader = (configPath)=>{
        if (isEsmFile(configPath) && utils_isTsFile(configPath)) return;
        if (!utils_isTsFile(configPath)) throw new Error(`config file "${configPath}" is not supported.`);
        (0, lib.addHook)((code, filename)=>{
            try {
                return compile(code, filename);
            } catch (err) {
                throw new Error(`Failed to transform file "${filename}" when loading TypeScript config file:\n ${err instanceof Error ? err.message : String(err)}`);
            }
        }, {
            exts: TS_EXTENSION
        });
    };
    const checkIsMultiRspackOptions = (config)=>Array.isArray(config);
    async function loadExtendedConfig(config, configPath, cwd, options) {
        if (checkIsMultiRspackOptions(config)) {
            const resultPathMap = new WeakMap();
            const extendedConfigs = await Promise.all(config.map(async (item)=>{
                const { config, pathMap } = await loadExtendedConfig(item, configPath, cwd, options);
                resultPathMap.set(config, pathMap.get(config));
                return config;
            }));
            extendedConfigs.parallelism = config.parallelism;
            return {
                config: extendedConfigs,
                pathMap: resultPathMap
            };
        }
        const pathMap = new WeakMap();
        pathMap.set(config, [
            configPath
        ]);
        if (!("extends" in config) || !config.extends) return {
            config,
            pathMap
        };
        const extendsList = Array.isArray(config.extends) ? config.extends : [
            config.extends
        ];
        const { extends: _, ...configWithoutExtends } = config;
        const baseDir = external_node_path_default().dirname(configPath);
        let resultConfig = configWithoutExtends;
        pathMap.set(resultConfig, [
            configPath
        ]);
        for (const extendPath of extendsList){
            let resolvedPath;
            if (extendPath.startsWith(".") || extendPath.startsWith("/") || extendPath.includes(":\\")) {
                resolvedPath = external_node_path_default().resolve(baseDir, extendPath);
                if (!external_node_path_default().extname(resolvedPath)) {
                    const foundConfig = utils_findConfig(resolvedPath);
                    if (foundConfig) resolvedPath = foundConfig;
                    else throw new Error(`Extended configuration file "${resolvedPath}" not found.`);
                }
            } else try {
                resolvedPath = require.resolve(extendPath, {
                    paths: [
                        baseDir,
                        cwd
                    ]
                });
            } catch  {
                throw new Error(`Cannot find module '${extendPath}' to extend from.`);
            }
            if (!external_node_fs_default().existsSync(resolvedPath)) throw new Error(`Extended configuration file "${resolvedPath}" not found.`);
            if (utils_isTsFile(resolvedPath) && "register" === options.configLoader) registerLoader(resolvedPath);
            let loadedConfig = await crossImport(resolvedPath);
            if ("function" == typeof loadedConfig) {
                loadedConfig = loadedConfig(options.env, options);
                if ("function" == typeof loadedConfig.then) loadedConfig = await loadedConfig;
            }
            const { config: extendedConfig, pathMap: extendedPathMap } = await loadExtendedConfig(loadedConfig, resolvedPath, cwd, options);
            const configPaths = [
                ...pathMap.get(resultConfig) || [],
                ...extendedPathMap.get(extendedConfig) || []
            ];
            resultConfig = rspackCore.Z.util.cleverMerge(extendedConfig, resultConfig);
            pathMap.set(resultConfig, configPaths);
        }
        return {
            config: resultConfig,
            pathMap
        };
    }
    async function loadRspackConfig(options, cwd = process.cwd()) {
        let configPath = "";
        if (options.config) {
            configPath = external_node_path_default().resolve(cwd, options.config);
            if (!external_node_fs_default().existsSync(configPath)) throw new Error(`config file "${configPath}" not found.`);
        } else {
            const defaultConfig = utils_findConfig(external_node_path_default().resolve(cwd, loadConfig_DEFAULT_CONFIG_NAME));
            if (!defaultConfig) return null;
            configPath = defaultConfig;
        }
        if (utils_isTsFile(configPath) && "register" === options.configLoader) registerLoader(configPath);
        const loadedConfig = await crossImport(configPath);
        return {
            loadedConfig,
            configPath
        };
    }
    class RspackCLI {
        colors;
        program;
        constructor(){
            const program = dist("rspack");
            this.colors = this.createColors();
            this.program = program;
            program.help();
            program.version("1.6.7");
        }
        async createCompiler(options, rspackCommand, callback) {
            let { config, pathMap } = await this.loadConfig(options);
            config = await this.buildConfig(config, pathMap, options, rspackCommand);
            const isWatch = Array.isArray(config) ? config.some((i)=>i.watch) : config.watch;
            let compiler;
            try {
                compiler = (0, rspackCore.Z)(config, isWatch ? callback : void 0);
                if (!isWatch && compiler) compiler.unsafeFastDrop = true;
            } catch (e) {
                if (e instanceof rspackCore.Z.ValidationError) {
                    this.getLogger().error(e.message);
                    process.exit(2);
                } else if (e instanceof Error) {
                    if ("function" == typeof callback) callback(e);
                    else this.getLogger().error(e);
                    return null;
                }
                throw e;
            }
            return compiler;
        }
        createColors(useColor) {
            const shouldUseColor = useColor || picocolors.isColorSupported;
            return {
                ...(0, picocolors.createColors)(shouldUseColor),
                isColorSupported: shouldUseColor
            };
        }
        getLogger() {
            return {
                error: (val)=>console.error(`[rspack-cli] ${this.colors.red(external_node_util_default().format(val))}`),
                warn: (val)=>console.warn(`[rspack-cli] ${this.colors.yellow(val)}`),
                info: (val)=>console.info(`[rspack-cli] ${this.colors.cyan(val)}`),
                success: (val)=>console.log(`[rspack-cli] ${this.colors.green(val)}`),
                log: (val)=>console.log(`[rspack-cli] ${val}`),
                raw: (val)=>console.log(val)
            };
        }
        async run(argv) {
            await this.registerCommands();
            this.program.parse(argv);
        }
        async registerCommands() {
            const builtinCommands = [
                new BuildCommand(),
                new ServeCommand(),
                new PreviewCommand()
            ];
            for (const command of builtinCommands)await command.apply(this);
        }
        async buildConfig(item, pathMap, options, command) {
            const isBuild = "build" === command;
            const isServe = "serve" === command;
            const internalBuildConfig = async (item)=>{
                if (options.entry) item.entry = {
                    main: options.entry.map((x)=>external_node_path_default().resolve(process.cwd(), x))[0]
                };
                item.output = item.output || {};
                if (options.outputPath) item.output.path = external_node_path_default().resolve(process.cwd(), options.outputPath);
                if (options.analyze) {
                    const { BundleAnalyzerPlugin } = await import("webpack-bundle-analyzer");
                    (item.plugins ??= []).push({
                        name: "rspack-bundle-analyzer",
                        apply (compiler) {
                            new BundleAnalyzerPlugin({
                                generateStatsFile: true
                            }).apply(compiler);
                        }
                    });
                }
                if (options.profile) item.profile = true;
                if (process.env.RSPACK_PROFILE) {
                    const { applyProfile } = await __webpack_require__.e("274").then(__webpack_require__.bind(__webpack_require__, "./src/utils/profile.ts"));
                    await applyProfile(process.env.RSPACK_PROFILE, process.env.RSPACK_TRACE_LAYER, process.env.RSPACK_TRACE_OUTPUT);
                }
                if (options.watch) item.watch = options.watch;
                if (!item.mode) item.mode = isBuild ? "production" : "development";
                if (options.mode) item.mode = options.mode;
                if (void 0 === item.devtool) item.devtool = isBuild ? "source-map" : "cheap-module-source-map";
                if (void 0 !== options.devtool) item.devtool = options.devtool;
                if (isServe) {
                    const installed = (item.plugins ||= []).find((item)=>item instanceof rspackCore.Z.ProgressPlugin);
                    if (!installed) (item.plugins ??= []).push(new rspackCore.Z.ProgressPlugin());
                }
                const cacheOptions = item.experiments?.cache;
                if ("object" == typeof cacheOptions && "persistent" === cacheOptions.type) {
                    const configPaths = pathMap.get(item);
                    if (configPaths) cacheOptions.buildDependencies = [
                        ...configPaths,
                        ...cacheOptions.buildDependencies || []
                    ];
                }
                if (void 0 === item.stats) item.stats = {
                    preset: "errors-warnings",
                    timings: true
                };
                else if ("boolean" == typeof item.stats) item.stats = item.stats ? {
                    preset: "normal"
                } : {
                    preset: "none"
                };
                else if ("string" == typeof item.stats) item.stats = {
                    preset: item.stats
                };
                if (this.colors.isColorSupported && void 0 === item.stats.colors) item.stats.colors = true;
                return item;
            };
            if (Array.isArray(item)) return Promise.all(item.map(internalBuildConfig));
            return internalBuildConfig(item);
        }
        async loadConfig(options) {
            const config = await loadRspackConfig(options);
            if (!config) return {
                config: this.filterConfig(options, {}),
                pathMap: new WeakMap()
            };
            let { loadedConfig, configPath } = config;
            if ("function" == typeof loadedConfig) {
                let functionResult = loadedConfig(options.env, options);
                if ("function" == typeof functionResult.then) functionResult = await functionResult;
                loadedConfig = functionResult;
            }
            const { config: extendedConfig, pathMap } = await loadExtendedConfig(loadedConfig, configPath, process.cwd(), options);
            return {
                config: this.filterConfig(options, extendedConfig),
                pathMap
            };
        }
        filterConfig(options, config) {
            if (options.configName) {
                const notFoundConfigNames = [];
                config = options.configName.map((configName)=>{
                    let found;
                    found = Array.isArray(config) ? config.find((options)=>options.name === configName) : config.name === configName ? config : void 0;
                    if (!found) notFoundConfigNames.push(configName);
                    return found;
                });
                if (notFoundConfigNames.length > 0) {
                    this.getLogger().error(notFoundConfigNames.map((configName)=>`Configuration with the name "${configName}" was not found.`).join(" "));
                    process.exit(2);
                }
            }
            return config;
        }
        isMultipleCompiler(compiler) {
            return Boolean(compiler.compilers);
        }
        isWatch(compiler) {
            return Boolean(this.isMultipleCompiler(compiler) ? compiler.compilers.some((compiler)=>compiler.options.watch) : compiler.options.watch);
        }
    }
    function defineConfig(config) {
        return config;
    }
    function definePlugin(plugin) {
        return plugin;
    }
})();
exports.RspackCLI = __webpack_exports__.RspackCLI;
exports.defineConfig = __webpack_exports__.defineConfig;
exports.definePlugin = __webpack_exports__.definePlugin;
for(var __rspack_i in __webpack_exports__)if (-1 === [
    "RspackCLI",
    "defineConfig",
    "definePlugin"
].indexOf(__rspack_i)) exports[__rspack_i] = __webpack_exports__[__rspack_i];
Object.defineProperty(exports, '__esModule', {
    value: true
});
